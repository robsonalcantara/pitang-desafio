const _global = (typeof window === 'undefined' ? global : window);
import { _dom as _ } from './dom-tools';
import { applyCssPrefixes, extendObject, } from '@ngbracket/ngx-layout/_private-utils';
export const expect = _global.expect;
/**
 * NOTE: These custom JASMINE Matchers are used only
 *       in the Karma/Jasmine testing for the Layout Directives
 *       in `src/lib/flex/api`
 */
export const customMatchers = {
    toEqual: function (util) {
        return {
            compare: function (actual, expected) {
                return { pass: util.equals(actual, expected) };
            },
        };
    },
    toHaveText: function () {
        return {
            compare: function (actual, expectedText) {
                const actualText = elementText(actual);
                return {
                    pass: actualText == expectedText,
                    get message() {
                        return 'Expected ' + actualText + ' to be equal to ' + expectedText;
                    },
                };
            },
        };
    },
    toHaveCssClass: function () {
        return { compare: buildError(false), negativeCompare: buildError(true) };
        function buildError(isNot) {
            return function (actual, className) {
                return {
                    pass: _.hasClass(actual, className) == !isNot,
                    get message() {
                        return `
              Expected ${actual.outerHTML} ${isNot ? 'not ' : ''}
              to contain the CSS class '${className}'
            `;
                    },
                };
            };
        }
    },
    toHaveMap: function () {
        return {
            compare: function (actual, map) {
                let allPassed;
                allPassed = Object.keys(map).length !== 0;
                Object.keys(map).forEach((key) => {
                    allPassed = allPassed && actual[key] === map[key];
                });
                return {
                    pass: allPassed,
                    get message() {
                        return `
              Expected ${JSON.stringify(actual)} ${!allPassed ? ' ' : 'not '} to contain the
              '${JSON.stringify(map)}'
            `;
                    },
                };
            },
        };
    },
    toHaveAttributes: function () {
        return {
            compare: function (actual, map) {
                let allPassed;
                let attributeNames = Object.keys(map);
                allPassed = attributeNames.length !== 0;
                attributeNames.forEach((name) => {
                    allPassed =
                        allPassed &&
                            _.hasAttribute(actual, name) &&
                            _.getAttribute(actual, name) === map[name];
                });
                return {
                    pass: allPassed,
                    get message() {
                        return `
              Expected ${actual.outerHTML} ${allPassed ? 'not ' : ''} attributes to contain
              '${JSON.stringify(map)}'
            `;
                    },
                };
            },
        };
    },
    /**
     * Check element's inline styles only
     */
    toHaveStyle: function () {
        return {
            compare: buildCompareStyleFunction(true),
        };
    },
    /**
     * Check element's css stylesheet only (if not present inline)
     */
    toHaveCSS: function () {
        return {
            compare: buildCompareStyleFunction(false),
        };
    },
};
/**
 * Curried value to function to check styles that are inline or in a stylesheet for the
 * specified DOM element.
 */
function buildCompareStyleFunction(inlineOnly = true) {
    return function (actual, styles, styler) {
        const found = {};
        const styleMap = {};
        if (typeof styles === 'string') {
            styleMap[styles] = '';
        }
        else {
            Object.assign(styleMap, styles);
        }
        let allPassed = Object.keys(styleMap).length !== 0;
        Object.keys(styleMap).forEach((prop) => {
            let { elHasStyle, current } = hasPrefixedStyles(actual, prop, styleMap[prop], inlineOnly, styler);
            allPassed = allPassed && elHasStyle;
            if (!elHasStyle) {
                extendObject(found, current);
            }
        });
        return {
            pass: allPassed,
            get message() {
                const expectedValueStr = typeof styles === 'string'
                    ? styleMap
                    : JSON.stringify(styleMap, null, 2);
                const foundValueStr = inlineOnly
                    ? actual.outerHTML
                    : JSON.stringify(found);
                return `
          Expected ${foundValueStr}${!allPassed ? '' : ' not'} to contain the
          CSS ${typeof styles === 'string' ? 'property' : 'styles'} '${expectedValueStr}'
        `;
            },
        };
    };
}
/**
 * Validate presence of requested style or use fallback
 * to possible `prefixed` styles. Useful when some browsers
 * (Safari, IE, etc) will use prefixed style instead of defaults.
 */
function hasPrefixedStyles(actual, key, value, inlineOnly, styler) {
    const current = {};
    if (value === '*') {
        return {
            elHasStyle: styler.lookupStyle(actual, key, inlineOnly) !== '',
            current,
        };
    }
    value = value.trim();
    let elHasStyle = styler.lookupStyle(actual, key, inlineOnly) === value;
    if (!elHasStyle) {
        let prefixedStyles = applyCssPrefixes({ [key]: value });
        Object.keys(prefixedStyles).forEach((prop) => {
            // Search for optional prefixed values
            elHasStyle =
                elHasStyle ||
                    styler.lookupStyle(actual, prop, inlineOnly) === prefixedStyles[prop];
        });
    }
    // Return BOTH confirmation and current computed key values (if confirmation == false)
    return { elHasStyle, current };
}
function elementText(n) {
    const hasNodes = (m) => {
        const children = _.childNodes(m);
        return children && children['length'];
    };
    if (n instanceof Array) {
        return n.map(elementText).join('');
    }
    if (_.isCommentNode(n)) {
        return '';
    }
    if (_.isElementNode(n) && _.tagName(n) == 'CONTENT') {
        return elementText(Array.prototype.slice.apply(_.getDistributedNodes(n)));
    }
    if (_.hasShadowRoot(n)) {
        return elementText(_.childNodesAsList(_.getShadowRoot(n)));
    }
    if (hasNodes(n)) {
        return elementText(_.childNodesAsList(n));
    }
    return _.getText(n);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VzdG9tLW1hdGNoZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbGlicy9mbGV4LWxheW91dC9fcHJpdmF0ZS11dGlscy90ZXN0aW5nL2N1c3RvbS1tYXRjaGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFRQSxNQUFNLE9BQU8sR0FBUSxDQUFDLE9BQU8sTUFBTSxLQUFLLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUV2RSxPQUFPLEVBQUUsSUFBSSxJQUFJLENBQUMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUd4QyxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLFlBQVksR0FDYixNQUFNLHNDQUFzQyxDQUFDO0FBRTlDLE1BQU0sQ0FBQyxNQUFNLE1BQU0sR0FBcUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQTBEdkU7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBbUM7SUFDNUQsT0FBTyxFQUFFLFVBQVUsSUFBSTtRQUNyQixPQUFPO1lBQ0wsT0FBTyxFQUFFLFVBQVUsTUFBVyxFQUFFLFFBQWE7Z0JBQzNDLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQztZQUNqRCxDQUFDO1NBQ0YsQ0FBQztJQUNKLENBQUM7SUFFRCxVQUFVLEVBQUU7UUFDVixPQUFPO1lBQ0wsT0FBTyxFQUFFLFVBQVUsTUFBVyxFQUFFLFlBQW9CO2dCQUNsRCxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3ZDLE9BQU87b0JBQ0wsSUFBSSxFQUFFLFVBQVUsSUFBSSxZQUFZO29CQUNoQyxJQUFJLE9BQU87d0JBQ1QsT0FBTyxXQUFXLEdBQUcsVUFBVSxHQUFHLGtCQUFrQixHQUFHLFlBQVksQ0FBQztvQkFDdEUsQ0FBQztpQkFDRixDQUFDO1lBQ0osQ0FBQztTQUNGLENBQUM7SUFDSixDQUFDO0lBRUQsY0FBYyxFQUFFO1FBQ2QsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUUsZUFBZSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBRXpFLFNBQVMsVUFBVSxDQUFDLEtBQWM7WUFDaEMsT0FBTyxVQUFVLE1BQVcsRUFBRSxTQUFpQjtnQkFDN0MsT0FBTztvQkFDTCxJQUFJLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLO29CQUM3QyxJQUFJLE9BQU87d0JBQ1QsT0FBTzt5QkFDTSxNQUFNLENBQUMsU0FBUyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFOzBDQUN0QixTQUFTO2FBQ3RDLENBQUM7b0JBQ0osQ0FBQztpQkFDRixDQUFDO1lBQ0osQ0FBQyxDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFRCxTQUFTLEVBQUU7UUFDVCxPQUFPO1lBQ0wsT0FBTyxFQUFFLFVBQ1AsTUFBK0IsRUFDL0IsR0FBNEI7Z0JBRTVCLElBQUksU0FBa0IsQ0FBQztnQkFDdkIsU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQztnQkFDMUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtvQkFDL0IsU0FBUyxHQUFHLFNBQVMsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNwRCxDQUFDLENBQUMsQ0FBQztnQkFFSCxPQUFPO29CQUNMLElBQUksRUFBRSxTQUFTO29CQUNmLElBQUksT0FBTzt3QkFDVCxPQUFPO3lCQUNNLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQ2pDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQ3JCO2lCQUNLLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDO2FBQ3ZCLENBQUM7b0JBQ0osQ0FBQztpQkFDRixDQUFDO1lBQ0osQ0FBQztTQUNGLENBQUM7SUFDSixDQUFDO0lBRUQsZ0JBQWdCLEVBQUU7UUFDaEIsT0FBTztZQUNMLE9BQU8sRUFBRSxVQUFVLE1BQVcsRUFBRSxHQUE0QjtnQkFDMUQsSUFBSSxTQUFrQixDQUFDO2dCQUN2QixJQUFJLGNBQWMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUN0QyxTQUFTLEdBQUcsY0FBYyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7Z0JBQ3hDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtvQkFDOUIsU0FBUzt3QkFDUCxTQUFTOzRCQUNULENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQzs0QkFDNUIsQ0FBQyxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMvQyxDQUFDLENBQUMsQ0FBQztnQkFDSCxPQUFPO29CQUNMLElBQUksRUFBRSxTQUFTO29CQUNmLElBQUksT0FBTzt3QkFDVCxPQUFPO3lCQUNNLE1BQU0sQ0FBQyxTQUFTLElBQzNCLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUN2QjtpQkFDSyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQzthQUN2QixDQUFDO29CQUNKLENBQUM7aUJBQ0YsQ0FBQztZQUNKLENBQUM7U0FDRixDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0gsV0FBVyxFQUFFO1FBQ1gsT0FBTztZQUNMLE9BQU8sRUFBRSx5QkFBeUIsQ0FBQyxJQUFJLENBQUM7U0FDekMsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNILFNBQVMsRUFBRTtRQUNULE9BQU87WUFDTCxPQUFPLEVBQUUseUJBQXlCLENBQUMsS0FBSyxDQUFDO1NBQzFDLENBQUM7SUFDSixDQUFDO0NBQ0YsQ0FBQztBQUVGOzs7R0FHRztBQUNILFNBQVMseUJBQXlCLENBQUMsVUFBVSxHQUFHLElBQUk7SUFDbEQsT0FBTyxVQUNMLE1BQVcsRUFDWCxNQUF3QyxFQUN4QyxNQUFrQjtRQUVsQixNQUFNLEtBQUssR0FBRyxFQUFFLENBQUM7UUFDakIsTUFBTSxRQUFRLEdBQTRCLEVBQUUsQ0FBQztRQUU3QyxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRSxDQUFDO1lBQy9CLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDeEIsQ0FBQzthQUFNLENBQUM7WUFDTixNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNsQyxDQUFDO1FBRUQsSUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO1FBQ25ELE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDckMsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsR0FBRyxpQkFBaUIsQ0FDN0MsTUFBTSxFQUNOLElBQUksRUFDSixRQUFRLENBQUMsSUFBSSxDQUFDLEVBQ2QsVUFBVSxFQUNWLE1BQU0sQ0FDUCxDQUFDO1lBQ0YsU0FBUyxHQUFHLFNBQVMsSUFBSSxVQUFVLENBQUM7WUFDcEMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNoQixZQUFZLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQy9CLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU87WUFDTCxJQUFJLEVBQUUsU0FBUztZQUNmLElBQUksT0FBTztnQkFDVCxNQUFNLGdCQUFnQixHQUNwQixPQUFPLE1BQU0sS0FBSyxRQUFRO29CQUN4QixDQUFDLENBQUMsUUFBUTtvQkFDVixDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUN4QyxNQUFNLGFBQWEsR0FBRyxVQUFVO29CQUM5QixDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVM7b0JBQ2xCLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUMxQixPQUFPO3FCQUNNLGFBQWEsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNO2dCQUVqRCxPQUFPLE1BQU0sS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsUUFDNUMsS0FBSyxnQkFBZ0I7U0FDdEIsQ0FBQztZQUNKLENBQUM7U0FDRixDQUFDO0lBQ0osQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFTLGlCQUFpQixDQUN4QixNQUFtQixFQUNuQixHQUFXLEVBQ1gsS0FBYSxFQUNiLFVBQW1CLEVBQ25CLE1BQWtCO0lBRWxCLE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQztJQUVuQixJQUFJLEtBQUssS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUNsQixPQUFPO1lBQ0wsVUFBVSxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxVQUFVLENBQUMsS0FBSyxFQUFFO1lBQzlELE9BQU87U0FDUixDQUFDO0lBQ0osQ0FBQztJQUVELEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDckIsSUFBSSxVQUFVLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLFVBQVUsQ0FBQyxLQUFLLEtBQUssQ0FBQztJQUN2RSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDaEIsSUFBSSxjQUFjLEdBQUcsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7UUFDeEQsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUMzQyxzQ0FBc0M7WUFDdEMsVUFBVTtnQkFDUixVQUFVO29CQUNWLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxVQUFVLENBQUMsS0FBSyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUUsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBQ0Qsc0ZBQXNGO0lBQ3RGLE9BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLENBQUM7QUFDakMsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUFDLENBQU07SUFDekIsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFNLEVBQUUsRUFBRTtRQUMxQixNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLE9BQU8sUUFBUSxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN4QyxDQUFDLENBQUM7SUFFRixJQUFJLENBQUMsWUFBWSxLQUFLLEVBQUUsQ0FBQztRQUN2QixPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCxJQUFJLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUN2QixPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxJQUFJLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLEVBQUUsQ0FBQztRQUNwRCxPQUFPLFdBQVcsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RSxDQUFDO0lBRUQsSUFBSSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDdkIsT0FBTyxXQUFXLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFRCxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2hCLE9BQU8sV0FBVyxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRCxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZGVjbGFyZSB2YXIgZ2xvYmFsOiBhbnk7XG5jb25zdCBfZ2xvYmFsID0gPGFueT4odHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3cpO1xuXG5pbXBvcnQgeyBfZG9tIGFzIF8gfSBmcm9tICcuL2RvbS10b29scyc7XG5cbmltcG9ydCB7IFN0eWxlVXRpbHMgfSBmcm9tICdAbmdicmFja2V0L25neC1sYXlvdXQvY29yZSc7XG5pbXBvcnQge1xuICBhcHBseUNzc1ByZWZpeGVzLFxuICBleHRlbmRPYmplY3QsXG59IGZyb20gJ0BuZ2JyYWNrZXQvbmd4LWxheW91dC9fcHJpdmF0ZS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBleHBlY3Q6IChhY3R1YWw6IGFueSkgPT4gTmdNYXRjaGVycyA9IDxhbnk+X2dsb2JhbC5leHBlY3Q7XG5cbi8qKlxuICogSmFzbWluZSBtYXRjaGVycyB0aGF0IGNoZWNrIEFuZ3VsYXIgc3BlY2lmaWMgY29uZGl0aW9ucy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZ01hdGNoZXJzIGV4dGVuZHMgamFzbWluZS5NYXRjaGVyczxhbnk+IHtcbiAgLyoqXG4gICAqIEV4cGVjdCB0aGUgZWxlbWVudCB0byBoYXZlIGV4YWN0bHkgdGhlIGdpdmVuIHRleHQuXG4gICAqXG4gICAqICMjIEV4YW1wbGVcbiAgICpcbiAgICoge0BleGFtcGxlIHRlc3RpbmcvdHMvbWF0Y2hlcnMudHMgcmVnaW9uPSd0b0hhdmVUZXh0J31cbiAgICovXG4gIHRvSGF2ZVRleHQoZXhwZWN0ZWQ6IHN0cmluZyk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENvbXBhcmUga2V5OnZhbHVlIHBhaXJzIGFzIG1hdGNoaW5nIEVYQUNUTFlcbiAgICovXG4gIHRvSGF2ZU1hcChleHBlY3RlZDogeyBbazogc3RyaW5nXTogc3RyaW5nIH0pOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhlIGVsZW1lbnQgdG8gaGF2ZSB0aGUgZ2l2ZW4gQ1NTIGNsYXNzLlxuICAgKlxuICAgKiAjIyBFeGFtcGxlXG4gICAqXG4gICAqIHtAZXhhbXBsZSB0ZXN0aW5nL3RzL21hdGNoZXJzLnRzIHJlZ2lvbj0ndG9IYXZlQ3NzQ2xhc3MnfVxuICAgKi9cbiAgdG9IYXZlQ3NzQ2xhc3MoZXhwZWN0ZWQ6IHN0cmluZyk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEV4cGVjdCB0aGUgZWxlbWVudCB0byBoYXZlIHRoZSBnaXZlbiBwYWlycyBvZiBhdHRyaWJ1dGUgbmFtZSBhbmQgYXR0cmlidXRlIHZhbHVlXG4gICAqL1xuICB0b0hhdmVBdHRyaWJ1dGVzKGV4cGVjdGVkOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfSk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEV4cGVjdCB0aGUgZWxlbWVudCB0byBoYXZlIHRoZSBnaXZlbiBDU1Mgc3R5bGVzIGluamVjdGVkIElOTElORVxuICAgKlxuICAgKiAjIyBFeGFtcGxlXG4gICAqXG4gICAqIHtAZXhhbXBsZSB0ZXN0aW5nL3RzL21hdGNoZXJzLnRzIHJlZ2lvbj0ndG9IYXZlU3R5bGUnfVxuICAgKi9cbiAgdG9IYXZlU3R5bGUoZXhwZWN0ZWQ6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9IHwgc3RyaW5nKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogRXhwZWN0IHRoZSBlbGVtZW50IHRvIGhhdmUgdGhlIGdpdmVuIENTUyBpbmxpbmUgT1IgY29tcHV0ZWQgc3R5bGVzLlxuICAgKlxuICAgKiAjIyBFeGFtcGxlXG4gICAqXG4gICAqIHtAZXhhbXBsZSB0ZXN0aW5nL3RzL21hdGNoZXJzLnRzIHJlZ2lvbj0ndG9IYXZlU3R5bGUnfVxuICAgKi9cbiAgdG9IYXZlU3R5bGUoZXhwZWN0ZWQ6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9IHwgc3RyaW5nKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW52ZXJ0IHRoZSBtYXRjaGVycy5cbiAgICovXG4gIG5vdDogTmdNYXRjaGVycztcbn1cblxuLyoqXG4gKiBOT1RFOiBUaGVzZSBjdXN0b20gSkFTTUlORSBNYXRjaGVycyBhcmUgdXNlZCBvbmx5XG4gKiAgICAgICBpbiB0aGUgS2FybWEvSmFzbWluZSB0ZXN0aW5nIGZvciB0aGUgTGF5b3V0IERpcmVjdGl2ZXNcbiAqICAgICAgIGluIGBzcmMvbGliL2ZsZXgvYXBpYFxuICovXG5leHBvcnQgY29uc3QgY3VzdG9tTWF0Y2hlcnM6IGphc21pbmUuQ3VzdG9tTWF0Y2hlckZhY3RvcmllcyA9IHtcbiAgdG9FcXVhbDogZnVuY3Rpb24gKHV0aWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24gKGFjdHVhbDogYW55LCBleHBlY3RlZDogYW55KSB7XG4gICAgICAgIHJldHVybiB7IHBhc3M6IHV0aWwuZXF1YWxzKGFjdHVhbCwgZXhwZWN0ZWQpIH07XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG5cbiAgdG9IYXZlVGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbiAoYWN0dWFsOiBhbnksIGV4cGVjdGVkVGV4dDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFRleHQgPSBlbGVtZW50VGV4dChhY3R1YWwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbFRleHQgPT0gZXhwZWN0ZWRUZXh0LFxuICAgICAgICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICAgICAgcmV0dXJuICdFeHBlY3RlZCAnICsgYWN0dWFsVGV4dCArICcgdG8gYmUgZXF1YWwgdG8gJyArIGV4cGVjdGVkVGV4dDtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxuXG4gIHRvSGF2ZUNzc0NsYXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHsgY29tcGFyZTogYnVpbGRFcnJvcihmYWxzZSksIG5lZ2F0aXZlQ29tcGFyZTogYnVpbGRFcnJvcih0cnVlKSB9O1xuXG4gICAgZnVuY3Rpb24gYnVpbGRFcnJvcihpc05vdDogYm9vbGVhbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3R1YWw6IGFueSwgY2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBfLmhhc0NsYXNzKGFjdHVhbCwgY2xhc3NOYW1lKSA9PSAhaXNOb3QsXG4gICAgICAgICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICBFeHBlY3RlZCAke2FjdHVhbC5vdXRlckhUTUx9ICR7aXNOb3QgPyAnbm90ICcgOiAnJ31cbiAgICAgICAgICAgICAgdG8gY29udGFpbiB0aGUgQ1NTIGNsYXNzICcke2NsYXNzTmFtZX0nXG4gICAgICAgICAgICBgO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICB0b0hhdmVNYXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24gKFxuICAgICAgICBhY3R1YWw6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9LFxuICAgICAgICBtYXA6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9XG4gICAgICApIHtcbiAgICAgICAgbGV0IGFsbFBhc3NlZDogYm9vbGVhbjtcbiAgICAgICAgYWxsUGFzc2VkID0gT2JqZWN0LmtleXMobWFwKS5sZW5ndGggIT09IDA7XG4gICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgYWxsUGFzc2VkID0gYWxsUGFzc2VkICYmIGFjdHVhbFtrZXldID09PSBtYXBba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhbGxQYXNzZWQsXG4gICAgICAgICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICBFeHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KGFjdHVhbCl9ICR7XG4gICAgICAgICAgICAgICFhbGxQYXNzZWQgPyAnICcgOiAnbm90ICdcbiAgICAgICAgICAgIH0gdG8gY29udGFpbiB0aGVcbiAgICAgICAgICAgICAgJyR7SlNPTi5zdHJpbmdpZnkobWFwKX0nXG4gICAgICAgICAgICBgO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG5cbiAgdG9IYXZlQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbiAoYWN0dWFsOiBhbnksIG1hcDogeyBbazogc3RyaW5nXTogc3RyaW5nIH0pIHtcbiAgICAgICAgbGV0IGFsbFBhc3NlZDogYm9vbGVhbjtcbiAgICAgICAgbGV0IGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgICAgICAgYWxsUGFzc2VkID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoICE9PSAwO1xuICAgICAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgYWxsUGFzc2VkID1cbiAgICAgICAgICAgIGFsbFBhc3NlZCAmJlxuICAgICAgICAgICAgXy5oYXNBdHRyaWJ1dGUoYWN0dWFsLCBuYW1lKSAmJlxuICAgICAgICAgICAgXy5nZXRBdHRyaWJ1dGUoYWN0dWFsLCBuYW1lKSA9PT0gbWFwW25hbWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhbGxQYXNzZWQsXG4gICAgICAgICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICBFeHBlY3RlZCAke2FjdHVhbC5vdXRlckhUTUx9ICR7XG4gICAgICAgICAgICAgIGFsbFBhc3NlZCA/ICdub3QgJyA6ICcnXG4gICAgICAgICAgICB9IGF0dHJpYnV0ZXMgdG8gY29udGFpblxuICAgICAgICAgICAgICAnJHtKU09OLnN0cmluZ2lmeShtYXApfSdcbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgZWxlbWVudCdzIGlubGluZSBzdHlsZXMgb25seVxuICAgKi9cbiAgdG9IYXZlU3R5bGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogYnVpbGRDb21wYXJlU3R5bGVGdW5jdGlvbih0cnVlKSxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBlbGVtZW50J3MgY3NzIHN0eWxlc2hlZXQgb25seSAoaWYgbm90IHByZXNlbnQgaW5saW5lKVxuICAgKi9cbiAgdG9IYXZlQ1NTOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGJ1aWxkQ29tcGFyZVN0eWxlRnVuY3Rpb24oZmFsc2UpLFxuICAgIH07XG4gIH0sXG59O1xuXG4vKipcbiAqIEN1cnJpZWQgdmFsdWUgdG8gZnVuY3Rpb24gdG8gY2hlY2sgc3R5bGVzIHRoYXQgYXJlIGlubGluZSBvciBpbiBhIHN0eWxlc2hlZXQgZm9yIHRoZVxuICogc3BlY2lmaWVkIERPTSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBidWlsZENvbXBhcmVTdHlsZUZ1bmN0aW9uKGlubGluZU9ubHkgPSB0cnVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoXG4gICAgYWN0dWFsOiBhbnksXG4gICAgc3R5bGVzOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfSB8IHN0cmluZyxcbiAgICBzdHlsZXI6IFN0eWxlVXRpbHNcbiAgKSB7XG4gICAgY29uc3QgZm91bmQgPSB7fTtcbiAgICBjb25zdCBzdHlsZU1hcDogeyBbazogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcblxuICAgIGlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgc3R5bGVNYXBbc3R5bGVzXSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0eWxlTWFwLCBzdHlsZXMpO1xuICAgIH1cblxuICAgIGxldCBhbGxQYXNzZWQgPSBPYmplY3Qua2V5cyhzdHlsZU1hcCkubGVuZ3RoICE9PSAwO1xuICAgIE9iamVjdC5rZXlzKHN0eWxlTWFwKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBsZXQgeyBlbEhhc1N0eWxlLCBjdXJyZW50IH0gPSBoYXNQcmVmaXhlZFN0eWxlcyhcbiAgICAgICAgYWN0dWFsLFxuICAgICAgICBwcm9wLFxuICAgICAgICBzdHlsZU1hcFtwcm9wXSxcbiAgICAgICAgaW5saW5lT25seSxcbiAgICAgICAgc3R5bGVyXG4gICAgICApO1xuICAgICAgYWxsUGFzc2VkID0gYWxsUGFzc2VkICYmIGVsSGFzU3R5bGU7XG4gICAgICBpZiAoIWVsSGFzU3R5bGUpIHtcbiAgICAgICAgZXh0ZW5kT2JqZWN0KGZvdW5kLCBjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXNzOiBhbGxQYXNzZWQsXG4gICAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZVN0ciA9XG4gICAgICAgICAgdHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gc3R5bGVNYXBcbiAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoc3R5bGVNYXAsIG51bGwsIDIpO1xuICAgICAgICBjb25zdCBmb3VuZFZhbHVlU3RyID0gaW5saW5lT25seVxuICAgICAgICAgID8gYWN0dWFsLm91dGVySFRNTFxuICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoZm91bmQpO1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgIEV4cGVjdGVkICR7Zm91bmRWYWx1ZVN0cn0keyFhbGxQYXNzZWQgPyAnJyA6ICcgbm90J30gdG8gY29udGFpbiB0aGVcbiAgICAgICAgICBDU1MgJHtcbiAgICAgICAgICAgIHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnID8gJ3Byb3BlcnR5JyA6ICdzdHlsZXMnXG4gICAgICAgICAgfSAnJHtleHBlY3RlZFZhbHVlU3RyfSdcbiAgICAgICAgYDtcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBwcmVzZW5jZSBvZiByZXF1ZXN0ZWQgc3R5bGUgb3IgdXNlIGZhbGxiYWNrXG4gKiB0byBwb3NzaWJsZSBgcHJlZml4ZWRgIHN0eWxlcy4gVXNlZnVsIHdoZW4gc29tZSBicm93c2Vyc1xuICogKFNhZmFyaSwgSUUsIGV0Yykgd2lsbCB1c2UgcHJlZml4ZWQgc3R5bGUgaW5zdGVhZCBvZiBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gaGFzUHJlZml4ZWRTdHlsZXMoXG4gIGFjdHVhbDogSFRNTEVsZW1lbnQsXG4gIGtleTogc3RyaW5nLFxuICB2YWx1ZTogc3RyaW5nLFxuICBpbmxpbmVPbmx5OiBib29sZWFuLFxuICBzdHlsZXI6IFN0eWxlVXRpbHNcbikge1xuICBjb25zdCBjdXJyZW50ID0ge307XG5cbiAgaWYgKHZhbHVlID09PSAnKicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWxIYXNTdHlsZTogc3R5bGVyLmxvb2t1cFN0eWxlKGFjdHVhbCwga2V5LCBpbmxpbmVPbmx5KSAhPT0gJycsXG4gICAgICBjdXJyZW50LFxuICAgIH07XG4gIH1cblxuICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgbGV0IGVsSGFzU3R5bGUgPSBzdHlsZXIubG9va3VwU3R5bGUoYWN0dWFsLCBrZXksIGlubGluZU9ubHkpID09PSB2YWx1ZTtcbiAgaWYgKCFlbEhhc1N0eWxlKSB7XG4gICAgbGV0IHByZWZpeGVkU3R5bGVzID0gYXBwbHlDc3NQcmVmaXhlcyh7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICBPYmplY3Qua2V5cyhwcmVmaXhlZFN0eWxlcykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgLy8gU2VhcmNoIGZvciBvcHRpb25hbCBwcmVmaXhlZCB2YWx1ZXNcbiAgICAgIGVsSGFzU3R5bGUgPVxuICAgICAgICBlbEhhc1N0eWxlIHx8XG4gICAgICAgIHN0eWxlci5sb29rdXBTdHlsZShhY3R1YWwsIHByb3AsIGlubGluZU9ubHkpID09PSBwcmVmaXhlZFN0eWxlc1twcm9wXTtcbiAgICB9KTtcbiAgfVxuICAvLyBSZXR1cm4gQk9USCBjb25maXJtYXRpb24gYW5kIGN1cnJlbnQgY29tcHV0ZWQga2V5IHZhbHVlcyAoaWYgY29uZmlybWF0aW9uID09IGZhbHNlKVxuICByZXR1cm4geyBlbEhhc1N0eWxlLCBjdXJyZW50IH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRUZXh0KG46IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IGhhc05vZGVzID0gKG06IGFueSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gXy5jaGlsZE5vZGVzKG0pO1xuICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlblsnbGVuZ3RoJ107XG4gIH07XG5cbiAgaWYgKG4gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiBuLm1hcChlbGVtZW50VGV4dCkuam9pbignJyk7XG4gIH1cblxuICBpZiAoXy5pc0NvbW1lbnROb2RlKG4pKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKF8uaXNFbGVtZW50Tm9kZShuKSAmJiBfLnRhZ05hbWUobikgPT0gJ0NPTlRFTlQnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRUZXh0KEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShfLmdldERpc3RyaWJ1dGVkTm9kZXMobikpKTtcbiAgfVxuXG4gIGlmIChfLmhhc1NoYWRvd1Jvb3QobikpIHtcbiAgICByZXR1cm4gZWxlbWVudFRleHQoXy5jaGlsZE5vZGVzQXNMaXN0KF8uZ2V0U2hhZG93Um9vdChuKSkpO1xuICB9XG5cbiAgaWYgKGhhc05vZGVzKG4pKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRUZXh0KF8uY2hpbGROb2Rlc0FzTGlzdChuKSk7XG4gIH1cblxuICByZXR1cm4gXy5nZXRUZXh0KG4pO1xufVxuIl19